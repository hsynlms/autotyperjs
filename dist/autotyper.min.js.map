{"version":3,"sources":["autotyper.js"],"names":["window","document","autoTyper","opts","options","selector","words","charSpeed","delay","loop","flipflop","position","currentWord","element","isStopped","opt","hasOwnProperty","applyNewOptions","putChar","length","setTimeout","remChar","next","innerHTML","substr","processWord","word","exec","timeoutDelay","i","tmp","this","start","Array","isArray","el","querySelector","stop"],"mappings":";;;;;;CAAA,SAAAA,EAAAC,GACAD,EAAAE,UAAA,SAAAC,GACA,IAAAC,EAAA,CACAC,SAAA,GACAC,MAAA,GACAC,UAAA,GALAC,MAAA,KACAC,MAAA,EACAC,UAAA,EACAC,SAAA,EACAC,YAAA,GACAC,QAAA,KACAC,WAAA,IAGA,SAAAX,GACA,GAAAA,EAEA,IAAA,IAAAY,KAAAZ,EACAA,EAAAa,eAAAD,KACAX,EAAAW,GAAAZ,EAAAY,IAIAE,CAAAd,GAGA,IAAAe,EAAA,aAEAd,EAAAO,WAAAP,EAAAQ,YAAAO,QAAAf,EAAAU,aAEAV,EAAAM,iBACAU,YAAA,WAEAC,IAAAC,SACAlB,EAAAI,cAIA,MAIAJ,EAAAS,QAAAU,WAAAnB,EAAAQ,YAAAR,EAAAO,kBAGAS,YAAA,WACAF,IAAAI,SACAlB,EAAAO,SAAAP,EAAAQ,YAAAO,OAAAf,EAAAG,UAAA,IAIAc,EAAA,aAEA,IAAAjB,EAAAO,UAAAP,EAAAU,mBAAA,MAGAV,EAAAS,QAAAU,UAAAnB,EAAAQ,YAAAY,OAAA,IAAApB,EAAAO,gBAGAS,YAAA,WACAC,IAAAC,SACAlB,EAAAO,SAAA,EAAAP,EAAAG,UAAA,IAIAkB,EAAA,UAAAC,EAAAlB,SACAY,YAAA,WAEAhB,EAAAO,SAAA,EACAP,EAAAQ,YAAAc,EACAtB,EAAAS,QAAAU,UAAA,GAGAL,IAAAI,SACAd,IAGAmB,EAAA,YAEAvB,EAAAU,kBAAA,MAIA,IAFA,IAAAc,EAAA,EAEAC,EAAA,EAAAA,EAAAzB,EAAAE,MAAAa,OAAAU,IAAA,CAGA,GAFAzB,EAAAE,MAAAuB,GAEA,CAEAJ,EAAArB,EAAAE,MAAAuB,GAAAD,GAAAN,OAEA,IAAAQ,EAAA1B,EAAAE,MAAAuB,GAAAV,OAAAf,EAAAG,UACAH,EAAAM,WAAAoB,GAAA,GAEAF,GAAAE,EAAA1B,EAAAI,aAGAY,YAAA,WACAhB,EAAAK,MAAAkB,IAAAL,SACAM,IAGAG,KAAAC,MAAA,WACA,GAAA,iBAAA5B,EAAAC,UAAAD,EAAAC,UACA4B,MAAAC,QAAA9B,EAAAE,QAAAF,EAAAE,MAAAa,OAAA,CAEA,IAAAgB,EAAAlC,EAAAmC,cAAAhC,EAAAC,UACA8B,IAEA/B,EAAAS,QAAAsB,EACA/B,EAAAU,WAAA,EAEAa,IAAAL,UAGAS,KAAAM,KAAA,WAEAjC,EAAAU,WAAA,EACAV,EAAAO,SAAA,EACAP,EAAAQ,YAAA,KAjHA,CAoHAZ,OAAAC","file":"autotyper.min.js","sourcesContent":["(function (window, document) {\n  window.autoTyper = function (opts) {\n    var options = {\n      selector: '',\n      words: [],\n      charSpeed: 85,\n      delay: 2100,\n      loop: true,\n      flipflop: true,\n      position: 0,\n      currentWord: '',\n      element: null,\n      isStopped: false\n    }\n\n    var applyNewOptions = function (opts) {\n      if (!opts) return\n\n      for (var opt in opts) {\n        if (opts.hasOwnProperty(opt)) {\n          options[opt] = opts[opt]\n        }\n      }\n    }\n    applyNewOptions(opts)\n\n    // put characters synchronously\n    var putChar = function*() {\n      // if current character is last or its stopped\n      if (options.position === options.currentWord.length || options.isStopped) {\n        // check if flip flop is activated\n        if (options.flipflop) {\n          yield setTimeout(function () {\n            // after the delay, start removing chars one by one\n            remChar().next()\n          }, options.delay)\n        }\n\n        // exit\n        yield null\n      }\n\n      // append the char into the element\n      options.element.innerHTML += options.currentWord[options.position++]\n\n      // loop the function for other remained chars\n      yield setTimeout(function () {\n        putChar().next()\n      }, (options.position < options.currentWord.length) ? options.charSpeed : 0)\n    }\n\n    // remove characters synchronously\n    var remChar = function*() {\n      // if all chars is removed or its stopped, exit function\n      if (options.position === 0 || options.isStopped) yield null\n\n      // remove the char from the element\n      options.element.innerHTML = options.currentWord.substr(0, --options.position)\n\n      // loop the function for other remained chars\n      yield setTimeout(function () {\n        remChar().next()\n      }, (options.position > 0) ? options.charSpeed : 0)\n    }\n\n    // prepare words to be typed synchronously\n    var processWord = function*(word, delay) {\n      yield setTimeout(function () {\n        // reset options\n        options.position = 0\n        options.currentWord = word\n        options.element.innerHTML = ''\n\n        // start to put characters\n        putChar().next()\n      }, delay)\n    }\n\n    var exec = function*() {\n      // if its stopped, exit function\n      if (options.isStopped) yield null\n\n      var timeoutDelay = 0\n\n      for (var i = 0; i < options.words.length; i++) {\n        var theWord = options.words[i]\n\n        if (!theWord) continue\n\n        processWord(options.words[i], timeoutDelay).next()\n\n        var tmp = options.words[i].length * options.charSpeed\n        if (options.flipflop) tmp *= 2\n\n        timeoutDelay += (tmp + options.delay)\n      }\n\n      yield setTimeout(function () {\n        options.loop ? exec().next() : ''\n      }, timeoutDelay)\n    }\n\n    this.start = function () {\n      if (typeof options.selector !== 'string' || !options.selector) return\n      if (!Array.isArray(options.words) || !options.words.length) return\n\n      var el = document.querySelector(options.selector)\n      if (!el) return\n\n      options.element = el\n      options.isStopped = false\n\n      exec().next()\n    }\n\n    this.stop = function() {\n      // reset options\n      options.isStopped = true\n      options.position = 0\n      options.currentWord = ''\n    }\n  }\n})(window, document)\n"]}